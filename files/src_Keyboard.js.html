<!DOCTYPE html>
<html lang='en'>

<head>
  <title>Keyboard v0.1.0 API Documentation : src\Keyboard.js</title>
  <meta charset='utf-8'>
  <meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
  <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
  <link rel='shortcut icon' type='image/png' href='../assets/images/favicon.ico?v=0.1.0'>
  <link href='//fonts.googleapis.com/css?family=Titillium+Web:300,200,600' rel='stylesheet' type='text/css'>
  <link rel='stylesheet' type='text/css' href='../assets/css/libraries.css?v=0.1.0'>
  <link rel='stylesheet' type='text/css' href='../assets/css/main.css?v=0.1.0'>
</head>

<body>
  <header>
    <div class='container'>
      <div class='version pull-right'>
        <em>API Documentation for: 0.1.0</em>
      </div>
      <div class='logo'>

        <h1><a href='https://github.com/CloudKidStudio/Keyboard'><img src='../assets/images/logo.png?v=0.1.0' title='Keyboard'><span class='project-name'>Keyboard</span></a></h1> 
      </div>
<div class='scope-toggles pull-right'>
  <input class='scope-toggle' id='toggle-inherited' type='checkbox' data-toggle='toggle' data-on='Inherited' data-off='Inherited' data-size='mini'>
  <input class='scope-toggle' id='toggle-protected' type='checkbox' data-toggle='toggle' data-on='Protected' data-off='Protected' data-size='mini'>
  <input class='scope-toggle' id='toggle-private' type='checkbox' data-toggle='toggle' data-on='Private' data-off='Private' data-size='mini'>
  <input class='scope-toggle' id='toggle-deprecated' type='checkbox' data-toggle='toggle' data-on='Deprecated' data-off='Deprecated' data-size='mini'>
</div>    </div>
  </header>
  <div class='container'>
    <div class='row'>
      <nav id='sidebar' class='col-sm-4 col-md-3'>
<h2>APIs</h2>
<div class='input-group'>
  <div class='input-group-addon'>
    <span class='glyphicon glyphicon-search'></span>
  </div>
  <input type='search' class='form-control' id='api-filter' placeholder='Type to filter APIs'>
</div>
<nav class='navbar navbar-default'>
  <!-- Brand and toggle get grouped for better mobile display -->
  <div class="btn-group" role="group" aria-label="...">
    <button type="button" class="sidebar-toggle collapsed btn btn-default" id='toggle-classes' data-target='#classes-collapse'>
      Classes
      <span class='collapsed glyphicon glyphicon-chevron-up'></span>
      <span class='expanded glyphicon glyphicon-chevron-down'></span>
    </button>
    <button type="button" class="sidebar-toggle collapsed btn btn-default"id='toggle-modules'  data-target='#modules-collapse'>
      Modules
      <span class='collapsed glyphicon glyphicon-chevron-up'></span>
      <span class='expanded glyphicon glyphicon-chevron-down'></span>
    </button>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class='collapse' id='classes-collapse'>
    <ul class='nav navbar-nav'>
        <li class=''>
          <a href='../classes/cloudkid.Keyboard.html'>cloudkid.Keyboard</a>
        </li>
        <li class=''>
          <a href='../classes/cloudkid.KeyboardPlugin.html'>cloudkid.KeyboardPlugin</a>
        </li>
        <li class=''>
          <a href='../classes/cloudkid.USLocale.html'>cloudkid.USLocale</a>
        </li>
    </ul>
  </div>

  <!-- Collect the nav links, forms, and other content for toggling -->
  <div class='collapse' id='modules-collapse'>
    <ul class='nav navbar-nav'>
    </ul>
  </div>
  <!-- /.container-fluid -->
</nav>      </nav>
      <div class='col-sm-8 col-md-9'>
        <div id='docs-main' class='apidocs'>
<script>
  var name = {
  	{
  		name
  	}
  }
</script>
<h1 class="file-heading">File:src\Keyboard.js</h1>

<div class="file">
  <pre class="code prettyprint linenums">/**
 * @namespace cloudkid
 */
(function()
{
	var Application = include(&#x27;springroll.Application&#x27;),
		Debug = include(&#x27;springroll.Debug&#x27;, false);
	
	/**
	*  A class for easier keyboard controls, from simple key events to complex key combinations.
	*
	*  @class Keyboard
	*  @constructor
	*  @param {DOMElement} target The DOM element to listen to key events on.
	*  @param {Object} locale The keyboard locale, like cloudkid.USLocale, which defines keys to
	*                         keep track of.
	*/
	var Keyboard = function(target, locale)
	{
		//bind callbacks/listeners
		this._onFocusLost = this._onFocusLost.bind(this);
		this._onPaused = this._onPaused.bind(this);
		this._onResumed = this._onResumed.bind(this);
		this._update = this._update.bind(this);
		this._keyDown = this._keyDown.bind(this);
		this._keyUp = this._keyUp.bind(this);
		
		/**
		 * The DOM element that the key event listeners are attached to.
		 * @property {DOMElement} target
		 * @private
		 * @readOnly
		 */
		this.target = target;
		target.addEventListener(&#x27;onblur&#x27;, this._onFocusLost);
		
		/**
		 * All keys that are listened to, arranged by key code.
		 * @property {Object} _keysByCode
		 * @private
		 */
		var _keysByCode = this._keysByCode = {};
		/**
		 * All keys that are listened to, arranged by key name.
		 * @property {Object} _keysByName
		 * @private
		 */
		var _keysByName = this._keysByName = {};
		/**
		 * All key combinations that have been registered
		 * @property {Array} _activeCombos
		 * @private
		 */
		this._activeCombos = [];
		/**
		 * Keys that have been updated since the most recent frame update. This array gets wiped
		 * each _update call.
		 * @property {Array} _updatedKeys
		 * @private
		 */
		this._updatedKeys = [];
		
		/**
		 * The callback used when key detection has ended.
		 * @property {Function} detectKeyCallback
		 * @private
		 */
		this.detectKeyCallback = null;
		/**
		 * The key object that is used to cancel key detection.
		 * @property {Key} detectCancelKey
		 * @private
		 */
		this.detectCancelKey = null;
		
		for(var keyName in locale)
		{
			var codes = locale[keyName];
			if(!Array.isArray(codes))
				codes = [codes];
			var i, key = null;
			for(i = 0; i &lt; codes.length; ++i)
			{
				if(_keysByCode[codes[i]])
				{
					key = _keysByCode[codes[i]];
					break;
				}
			}
			if(!key)
				key = new Key();
			key.addName(keyName);
			key.addCode(codes);
			_keysByName[keyName] = key;
			for(i = 0; i &lt; codes.length; ++i)
			{
				_keysByCode[codes[i]] = key;
			}
		}
		
		this.enabled = true;
		
		var app = Application.instance;
		app.on(&#x27;paused&#x27;, this._onPaused);
		app.on(&#x27;resumed&#x27;, this._onResumed);
	};

	// Reference to the prototype
	var p = Keyboard.prototype;
	
	//=======
	//event type functions
	
	/**
	 * Adds a listener for keydown events on a specific key. The callback will be passed the key
	 * name, in case the same callback is used for multiple keys.
	 * @method addKeyDown
	 * @param {String} keyName The name of the key, from the locale, to listen for.
	 * @param {Function} callback The function to call when the key is first pressed.
	 * @param {Boolean} [preventDefault=false] If the key should have the default action prevented
	 *                                         while this listener is attached.
	 */
	p.addKeyDown = function(keyName, callback, preventDefault)
	{
		var key = this._keysByName[keyName];
		if(!key)
		{
			if(Debug)
				Debug.warn(&quot;No key found with name &#x27;&quot; + keyName + &quot;&#x27;&quot;);
			return;
		}
		
		key.addListener(callback, true, keyName, !!preventDefault);
	};
	
	/**
	 * Removes a listener for keydown events on a specific key.
	 * @method removeKeyDown
	 * @param {String} keyName The name of the key, from the locale, to listen for.
	 * @param {Function} callback The function to be removed from the listener list.
	 */
	p.removeKeyDown = function(keyName, callback)
	{
		var key = this._keysByName[keyName];
		if(key)
			key.addListener(callback, true);
	};
	
	/**
	 * Adds a listener for keyup events on a specific key. The callback will be passed the key
	 * name, in case the same callback is used for multiple keys.
	 * @method addKeyUp
	 * @param {String} keyName The name of the key, from the locale, to listen for.
	 * @param {Function} callback The function to call when the key is released.
	 * @param {Boolean} [preventDefault=false] If the key should have the default action prevented
	 *                                         while this listener is attached.
	 */
	p.addKeyUp = function(keyName, callback, preventDefault)
	{
		var key = this._keysByName[keyName];
		if(!key)
		{
			if(Debug)
				Debug.warn(&quot;No key found with name &#x27;&quot; + keyName + &quot;&#x27;&quot;);
			return;
		}
		
		key.addListener(callback, false, keyName, !!preventDefault);
	};
	
	/**
	 * Removes a listener for keyup events on a specific key.
	 * @method removeKeyUp
	 * @param {String} keyName The name of the key, from the locale, to listen for.
	 * @param {Function} callback The function to be removed from the listener list.
	 */
	p.removeKeyUp = function(keyName, callback)
	{
		var key = this._keysByName[keyName];
		if(key)
			key.addListener(callback, false);
	};
	
	/**
	 * Sets if the default browser action should be prevented on a specific key. This is good
	 * for keys that are only checked with justPressed(), isDown(), and justReleased().
	 * @method setPreventDefaultOnKey
	 * @param {String} keyName The name of the key, from the locale, to listen for.
	 * @param {Boolean} preventDefault If the key should have the default action prevented.
	 */
	p.setPreventDefaultOnKey = function(keyName, preventDefault)
	{
		var key = this._keysByName[keyName];
		if(key)
			key.preventDownDefault = preventDefault;
	};
	
	/**
	 * Creates a key combination. NOTE: this feature has not yet been completed.
	 * @method addCombo
	 * @param {String} comboString A string defining how the key combination functions.
	 * @param {Function} callback The function to called when the combination successfully fires.
	 * @param {Boolean} [preventDefault=true] If the combo should have the default action prevented,
	 *                                        for any successful step of it that is completed.
	 */
	p.addCombo = function(comboString, callback, preventDefault)
	{
		//preventDefault defaults to true here, to cancel stuff like ctrl+s
		if(preventDefault !== false)
			preventDefault = true;
		
		var combo,
			_activeCombos = this._activeCombos;
		for(var i = _activeCombos.length - 1; i &gt;= 0; --i)
		{
			if(_activeCombos[i].name == comboString &amp;&amp;
				_activeCombos[i].preventDefault == preventDefault)
			{
				combo = _activeCombos[i];
				break;
			}
		}
		if(!combo)
		{
			combo = new Combo(name, preventDefault, this._keysByName);
			_activeCombos.push(combo);
		}
		combo.addListener(callback);
	};
	
	/**
	 * Removes a listener for a key combination. If no listeners remain, that key
	 * combination is destroyed.
	 * @method removeKeyUp
	 * @param {String} comboString The comboString used to create the combination.
	 * @param {Function} callback The function to be removed from the listener list.
	 */
	p.removeCombo = function(comboString, callback)
	{
		var _activeCombos = this._activeCombos;
		for(var i = _activeCombos.length - 1; i &gt;= 0; --i)
		{
			if(_activeCombos[i].name == comboString)
			{
				if(_activeCombos[i].removeListener(callback))
				{
					if(i == _activeCombos.length - 1)
						_activeCombos.pop();
					else
						_activeCombos.splice(i, 1);
				}
			}
		}
	};
	
	/**
	 * Begins listening for the next key to be pressed (or repeated). The callback is passed
	 * the name of that key, so that it can then be used with other functions. Additionally, if
	 * the key pressed does not have a recognized keyCode, then an entry is created for it with the
	 * name &lt;code&gt;&#x27;key_%keyCode%&#x27;&lt;/code&gt;. If the cancel key is pressed, then the callback is passed
	 * &lt;code&gt;null&lt;/code&gt;.
	 * @method detectNextKey
	 * @param {Function} callback The function to be called when a key is pressed.
	 * @param {String} [cancelKey=&quot;esc&quot;] The name of the key to cancel the listener. If explictly
	 *                                   passed &lt;code&gt;null&lt;/code&gt;, then the &quot;esc&quot; key can be
	 *                                   detected and this action can only be cancelled with
	 *                                   stopDetecting().
	 */
	p.detectNextKey = function(callback, cancelKey)
	{
		if(cancelKey === undefined)
			cancelKey = this._keysByName.esc;
		else if(cancelKey)
			cancelKey = this._keysByName[cancelKey];
		
		this.detectKeyCallback = callback;
		this.detectCancelKey = cancelKey || null;
	};
	
	/**
	 * Cancels a detectNextKey() action.
	 * @method stopDetecting
	 */
	p.stopDetecting = function()
	{
		this.detectKeyCallback = null;
		this.detectCancelKey = null;
	};
	
	//=======
	//update checker functions
	
	/**
	 * Checks to see if a key has begun to be pressed since the last Application &#x27;update&#x27; event.
	 * @method justPressed
	 * @param {String} keyName The name of the key to check.
	 * @return {Boolean} If the key was just pressed or not.
	 */
	p.justPressed = function(keyName)
	{
		var key = this._keysByName[keyName];
		if(key)
			return key.justDown;
		else
			return false;
	};
	
	/**
	 * Checks to see if a key is being held down.
	 * @method isDown
	 * @param {String} keyName The name of the key to check.
	 * @return {Boolean} If the key is down or not.
	 */
	p.isDown = function(keyName)
	{
		var key = this._keysByName[keyName];
		if(key)
			return key.isDown;
		else
			return false;
	};
	
	/**
	 * Checks to see if a key has been released since the last Application &#x27;update&#x27; event.
	 * @method justReleased
	 * @param {String} keyName The name of the key to check.
	 * @return {Boolean} If the key was just released or not.
	 */
	p.justReleased = function(keyName)
	{
		var key = this._keysByName[keyName];
		if(key)
			return key.justUp;
		else
			return false;
	};
	
	/**
	* If the Keyboard should be handling key events or not. Setting this to false immediately
	* resets the status of any keys that are currently pressed.
	* @property {Object} enabled
	*/
	Object.defineProperty(p, &quot;enabled&quot;, {
		get: function() { return this._enabled; },
		set: function(value)
		{
			this._enabled = value;
			var target = this.target;
			target.removeEventListener(&#x27;keydown&#x27;, this._keyDown, true);
			target.removeEventListener(&#x27;keyup&#x27;, this._keyUp, true);
			Application.instance.off(&#x27;update&#x27;, this._update);
			if(value)
			{
				target.addEventListener(&#x27;keydown&#x27;, this._keyDown, true);
				target.addEventListener(&#x27;keyup&#x27;, this._keyUp, true);
				//use a really low priority to clear the key states after everything else has had
				//a chance to check them
				Application.instance.on(&#x27;update&#x27;, this._update, -1000);
			}
			else
				this.clearKeys();
		}
	});
	
	/**
	 * Clears the status of all keys that are pressed, requiring them to be released and pressed
	 * again.
	 * @method clearKeys
	 */
	p.clearKeys = function()
	{
		var _keysByCode = this._keysByCode;
		
		if(!_keysByCode) return;
		
		for(var code in _keysByCode)
		{
			var key = _keysByCode[code];
			key.isDown = key.justDown = key.justUp = false;
		}
	};
	
	/**
	 * Listener for when the target has lost focus, to call clearKeys().
	 * @method _onFocusLost
	 * @private
	 * @param {Event} ev The event from the DOM.
	 */
	p._onFocusLost = function(ev)
	{
		this.clearKeys();
	};
	
	/**
	 * Listener for Application &#x27;paused&#x27; events. Disables the Keyboard.
	 * @method _onPaused
	 * @private
	 */
	p._onPaused = function()
	{
		this.enabled = false;
	};
	
	/**
	 * Listener for Application &#x27;resumed&#x27; events. Enables the Keyboard and gives browser focus
	 * to the target.
	 * @method _onResumed
	 * @private
	 */
	p._onResumed = function()
	{
		this.enabled = true;
		
		var target = this.target;
		if(target &amp;&amp; target.focus)
			target.focus();
	};
	
	/**
	 * Listener for Application &#x27;update&#x27; events. This is created with a priority of -1000 so that
	 * it can reset justPressed() and justReleased() states after other code has had a chance to
	 * check them.
	 * @method _update
	 * @private
	 * @param  {Number} elapsed Milliseconds elapsed since the previous update.
	 */
	p._update = function(elapsed)
	{
		var _updatedKeys = this._updatedKeys;
		if(!_updatedKeys || !_updatedKeys.length) return;
		
		for(var i = _updatedKeys.length - 1; i &gt;= 0; --i)
		{
			var key = _updatedKeys[i];
			key.justDown = key.justUp = false;
		}
		_updatedKeys.length = 0;
	};
	
	/**
	 * Listener for keydown events on the target.
	 * @method _keyDown
	 * @private
	 * @param  {KeyboardEvent} ev The keyboard event.
	 */
	p._keyDown = function(ev)
	{
		var key = this._keysByCode[ev.keyCode];
		
		if(this.detectKeyCallback)
		{
			var callback = this.detectKeyCallback;
			this.detectKeyCallback = null;
			
			if(key &amp;&amp; key == this.detectCancelKey)
			{
				callback(null);
			}
			else
			{
				//because we are detecting the next key pressed, we should create
				//a new key - this feature is largely for creating keybindings, and it&#x27;s probable
				//we aren&#x27;t expecting all keycodes
				if(!key)
				{
					key = new Key(ev.keyCode, &quot;key_&quot; + ev.keyCode);
					this._keysByCode[ev.keyCode] = key;
					this._keysByName[key.name] = key;
				}
				callback(key.preferredName);
			}
		}
		
		var preventDefault = false;
		if(key &amp;&amp; !key.isDown)
		{
			key.isDown = key.justDown = true;
			if(this._updatedKeys.indexOf(key) == -1)
				this._updatedKeys.push(key);
			if(key.trigger())
				preventDefault = true;
			
			for(var i = this._activeCombos.length - 1; i &gt;= 0; --i)
			{
				if(this._activeCombos.testKey(key.code))
					preventDefault = true;
			}
		}
		if(preventDefault)
		{
			ev.preventDefault();
			return true;
		}
	};
	
	/**
	 * Listener for keyup events on the target.
	 * @method _keyUp
	 * @private
	 * @param  {KeyboardEvent} ev The keyboard event.
	 */
	p._keyUp = function(ev)
	{
		var key = this._keysByCode[ev.keyCode];
		
		var preventDefault = false;
		if(key &amp;&amp; key.isDown)
		{
			key.isDown = false;
			key.justUp = true;
			if(this._updatedKeys.indexOf(key) == -1)
				this._updatedKeys.push(key);
			if(key.trigger())
				preventDefault = true;
			
			//TODO: handle combos?
		}
		if(preventDefault)
		{
			ev.preventDefault();
			return true;
		}
	};
	
	/**
	 * Destroys the keyboard and removes all listeners. Do not use after this is called.
	 * @method destroy
	 */
	p.destroy = function()
	{
		this.enabled = false;
		var app = Application.instance;
		if(app)
		{
			app.off(&#x27;paused&#x27;, this._onPaused);
			app.off(&#x27;resumed&#x27;, this._onResumed);
		}
		this.target.removeEventListener(&#x27;onblur&#x27;, this._onFocusLost);
		var i;
		for(i in this._keysByCode)
			this._keysByCode[i].destroy();
		for(i = this._activeCombos.length - 1; i &gt;= 0; --i)
			this._activeCombos[i].destroy();
		this._keysByCode = this._keysByName = this._updatedKeys = this._activeCombos =
			this.target = null;
		this._update = this._keyDown = this._keyUp = this._onResumed = this._onPaused =
			this._onFocusLost = null;
	};
	
	// Assign to namespace
	namespace(&#x27;cloudkid&#x27;).Keyboard = Keyboard;
	
	
	//================= Internal Helper Classes ============
	var Key = function()
	{
		this.codes = [];
		this.names = [];
		//decides which name to send with key up/down events in case there is more
		//than one name - for example, choosing &#x27;clear&#x27; over &#x27;num_lock&#x27;
		this.preferredName = null;
		//listener functions
		this.upListeners = [];
		this.downListeners = [];
		this.preventDownDefault = false;
		this.preventUpDefault = false;
		
		this.isDown = false;
		this.justDown = false;
		this.justUp = false;
	};
	
	p = Key.prototype;
	
	p.addCode = function(code)
	{
		if(Array.isArray(code))
		{
			for(var i = 0; i &lt; code.length; ++i)
				this.codes.push(code[i]);
		}
		else
			this.codes.push(code);
	};
	
	p.addName = function(name)
	{
		if(!this.names.length)
			this.preferredName = name;
		this.names.push(name);
	};
	
	p.addListener = function(listener, isUp, requestedName, preventDefault)
	{
		var listeners = isUp ? this.upListeners : this.downListeners;
		if(listeners.indexOf(listener) == -1)
			listeners.push(listener);
		if(this.preferredName != requestedName)
			this.preferredName = requestedName;
		listener.preventDefault = preventDefault;
		if(preventDefault)
		{
			if(isUp)
				this.preventUpDefault = true;
			else
				this.preventDownDefault = true;
		}
	};
	
	p.removeListener = function(listener, isUp)
	{
		var listeners = isUp ? this.upListeners : this.downListeners,
			index = listeners.indexOf(listener);
		if(index &gt;= 0)
		{
			if(index &lt; 1)
				listeners.shift();
			else
				listeners.splice(index, 1);
		}
		//see if we should clear the prevent default status
		var preventDefault = false;
		for(index = listeners.length - 1; index &gt;= 0; --index)
		{
			if(listeners[i].preventDefault)
			{
				preventDefault = true;
				break;
			}
		}
		if(isUp)
			this.preventUpDefault = preventDefault;
		else
			this.preventDownDefault = preventDefault;
	};
	
	p.trigger = function()
	{
		var listeners = this.isDown ? this.downListeners : this.upListeners;
		for(var i = 0; i &lt; listeners.length; ++i)
		{
			listeners[i](this.preferredName);
		}
		return this.isDown ? this.preventDownDefault : this.preventUpDefault;
	};
	
	p.destroy = function()
	{
		this.codes = this.names = this.upListeners = this.downListeners = null;
	};
	
	var Combo = function(name, preventDefault, keysByNameRef)
	{
		this.name = name;
		this.listeners = [];
		this.steps = [];
		this.currentStep = 0;
		this.preventDefault = preventDefault;
		
		//TODO: use regex &amp; keysByNameRef to generate steps
	};
	
	p = Combo.prototype;
	
	//key is a keycode
	p.testKey = function(key)
	{
		//TODO: check key against current step
		//TODO: Trigger combo on own when complete
		//TODO: return a value if the combo was successful and the event default should be prevented
	};
	
	p.addListener = function(listener)
	{
		var listeners = this.listeners;
		if(listeners.indexOf(listener) == -1)
			listeners.push(listener);
	};
	
	p.removeListener = function(listener)
	{
		var listeners = this.listeners,
			index = listeners.indexOf(listener);
		if(index &gt;= 0)
		{
			if(index &lt; 1)
				listeners.shift();
			else
				listeners.splice(index, 1);
		}
		//if there are no more listeners, return true to tell the Keyboard to destroy it
		return listeners.length &lt; 1;
	};
	
	p.destroy = function()
	{
		this.listeners = this.steps = null;
	};

}());</pre>
</div>        </div>
      </div>
    </div>
  </div>
  <script src='../assets/js/libraries.js?v=0.1.0'></script>
  <script src='../assets/js/main.js?v=0.1.0'></script>
</body>
</html>